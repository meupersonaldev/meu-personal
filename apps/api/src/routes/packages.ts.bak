import { Router } from 'express';
import { z } from 'zod';
import { requireAuth, requireRole } from '../middleware/auth';
import { balanceService } from '../services/balance.service';
import { paymentIntentService } from '../services/payment-intent.service';
import { supabase } from '../config/supabase';
import { asyncErrorHandler } from '../middleware/errorHandler';
import { extractPagination } from '../middleware/pagination';
import { resolveDefaultFranqueadoraId } from '../services/franqueadora-contacts.service';

const router = Router();

async function fetchFranqueadoraIdFromUnit(unitId?: string | null): Promise<string | null> {
  if (!unitId) {
    return null;
  }

  const { data: academyDirect, error: academyDirectError } = await supabase
    .from('academies')
    .select('franqueadora_id')
    .eq('id', unitId)
    .single();

  if (!academyDirectError && academyDirect?.franqueadora_id) {
    return academyDirect.franqueadora_id;
  }

  const { data: unitData, error: unitError } = await supabase
    .from('units')
    .select('academy_legacy_id')
    .eq('id', unitId)
    .single();

  if (unitError || !unitData) {
    return null;
  }

  if (!unitData.academy_legacy_id) {
    return null;
  }

  const { data: legacyAcademy, error: legacyError } = await supabase
    .from('academies')
    .select('franqueadora_id')
    .eq('id', unitData.academy_legacy_id)
    .single();

  if (!legacyError && legacyAcademy?.franqueadora_id) {
    return legacyAcademy.franqueadora_id;
  }

  return null;
}

async function resolveFranqueadoraId(options: {
  franqueadoraId?: string | null;
  unitId?: string | null;
  allowFallback?: boolean;
}): Promise<string | null> {
  const { franqueadoraId, unitId, allowFallback = true } = options;

  if (franqueadoraId) {
    return franqueadoraId;
  }

  const fromUnit = await fetchFranqueadoraIdFromUnit(unitId);
  if (fromUnit) {
    return fromUnit;
  }

  if (!allowFallback) {
    return null;
  }

  return resolveDefaultFranqueadoraId();
}

async function ensureStudentAccessToUnit(studentId: string, unitId: string): Promise<boolean> {
  const { data, error } = await supabase
    .from('student_units')
    .select('id')
    .eq('student_id', studentId)
    .eq('unit_id', unitId)
    .limit(1);

  if (error) {
    console.warn('Falha ao validar acesso do aluno a unidade:', error.message);
    return false;
  }

  return !!(data && data.length > 0);
}

async function ensureTeacherAccessToUnit(teacherId: string, unitId: string): Promise<boolean> {
  const { data, error } = await supabase
    .from('teacher_units')
    .select('id')
    .eq('teacher_id', teacherId)
    .eq('unit_id', unitId)
    .limit(1);

  if (error) {
    console.warn('Falha ao validar acesso do professor a unidade:', error.message);
    return false;
  }

  return !!(data && data.length > 0);
}

// ---------------------------------------------------------------------------
// Catalogo de pacotes - alunos
router.get('/student', requireAuth, requireRole(['STUDENT', 'FRANQUIA', 'FRANQUEADORA']), asyncErrorHandler(async (req, res) => {
  const { franqueadora_id, unit_id } = req.query as { franqueadora_id?: string; unit_id?: string };
  const user = req.user;

  const franqueadoraId = await resolveFranqueadoraId({
    franqueadoraId: franqueadora_id,
    unitId: unit_id,
    allowFallback: true
  });

  if (!franqueadoraId) {
    return res.status(400).json({ error: 'franqueadora_id eh obrigatorio' });
  }

  if (user.role === 'STUDENT' && unit_id) {
    const hasAccess = await ensureStudentAccessToUnit(user.userId, unit_id);
    if (!hasAccess) {
      return res.status(403).json({ error: 'Acesso nao autorizado a esta unidade' });
    }
  }

  const { data, error } = await supabase
    .from('student_packages')
    .select('*')
    .eq('franqueadora_id', franqueadoraId)
    .eq('status', 'active')
    .order('price_cents', { ascending: true });

  if (error) {
    return res.status(500).json({ error: error.message });
  }

  res.json({ packages: data, franqueadora_id: franqueadoraId });
}));

// Catalogo de pacotes - professores
router.get('/professor', requireAuth, requireRole(['TEACHER', 'FRANQUIA', 'FRANQUEADORA']), asyncErrorHandler(async (req, res) => {
  const { franqueadora_id, unit_id } = req.query as { franqueadora_id?: string; unit_id?: string };
  const user = req.user;

  const franqueadoraId = await resolveFranqueadoraId({
    franqueadoraId: franqueadora_id,
    unitId: unit_id,
    allowFallback: true
  });

  if (!franqueadoraId) {
    return res.status(400).json({ error: 'franqueadora_id eh obrigatorio' });
  }

  if (user.role === 'TEACHER' && unit_id) {
    const hasAccess = await ensureTeacherAccessToUnit(user.userId, unit_id);
    if (!hasAccess) {
      return res.status(403).json({ error: 'Acesso nao autorizado a esta unidade' });
    }
  }

  const { data, error } = await supabase
    .from('hour_packages')
    .select('*')
    .eq('franqueadora_id', franqueadoraId)
    .eq('status', 'active')
    .order('price_cents', { ascending: true });

  if (error) {
    return res.status(500).json({ error: error.message });
  }

  res.json({ packages: data, franqueadora_id: franqueadoraId });
}));

// ---------------------------------------------------------------------------
// Checkout de pacotes - aluno
router.post('/student/checkout', requireAuth, requireRole(['STUDENT', 'ALUNO']), asyncErrorHandler(async (req, res) => {
  const schema = z.object({
    package_id: z.string().uuid(),
    unit_id: z.string().uuid().optional(),
    payment_method: z.enum(['PIX', 'BOLETO', 'CREDIT_CARD']).default('PIX')
  });

  const { package_id, unit_id, payment_method } = schema.parse(req.body);
  const user = req.user;

  const { data: packageData, error: packageError } = await supabase
    .from('student_packages')
    .select('*')
    .eq('id', package_id)
    .eq('status', 'active')
    .single();

  if (packageError || !packageData) {
    return res.status(404).json({ error: 'Pacote nao encontrado' });
  }

  if (user.role === 'STUDENT' && unit_id) {
    const hasAccess = await ensureStudentAccessToUnit(user.userId, unit_id);
    if (!hasAccess) {
      return res.status(403).json({ error: 'Acesso nao autorizado a esta unidade' });
    }
  }

  const franqueadoraId = packageData.franqueadora_id;
  if (!franqueadoraId) {
    return res.status(409).json({ error: 'Pacote sem franqueadora associada' });
  }

  const paymentIntent = await paymentIntentService.createPaymentIntent({
    type: 'STUDENT_PACKAGE',
    actorUserId: user.userId,
    franqueadoraId,
    unitId: unit_id,
    amountCents: packageData.price_cents,
    metadata: {
      package_id: packageData.id,
      package_title: packageData.title,
      classes_qty: packageData.classes_qty,
      payment_method
    }
  });

  res.status(201).json({
    message: 'Pagamento criado com sucesso',
    payment_intent: {
      id: paymentIntent.id,
      type: paymentIntent.type,
      status: paymentIntent.status,
      checkout_url: paymentIntent.checkout_url,
      created_at: paymentIntent.created_at
    },
    package: {
      title: packageData.title,
      classes_qty: packageData.classes_qty,
      price_cents: packageData.price_cents,
      franqueadora_id: franqueadoraId
    }
  });
}));

// Checkout de pacotes - professor
router.post('/professor/checkout', requireAuth, requireRole(['TEACHER', 'PROFESSOR']), asyncErrorHandler(async (req, res) => {
  const schema = z.object({
    package_id: z.string().uuid(),
    unit_id: z.string().uuid().optional(),
    payment_method: z.enum(['PIX', 'BOLETO', 'CREDIT_CARD']).default('PIX')
  });

  const { package_id, unit_id, payment_method } = schema.parse(req.body);
  const user = req.user;

  const { data: packageData, error: packageError } = await supabase
    .from('hour_packages')
    .select('*')
    .eq('id', package_id)
    .eq('status', 'active')
    .single();

  if (packageError || !packageData) {
    return res.status(404).json({ error: 'Pacote nao encontrado' });
  }

  if (user.role === 'TEACHER' && unit_id) {
    const hasAccess = await ensureTeacherAccessToUnit(user.userId, unit_id);
    if (!hasAccess) {
      return res.status(403).json({ error: 'Acesso nao autorizado a esta unidade' });
    }
  }

  const franqueadoraId = packageData.franqueadora_id;
  if (!franqueadoraId) {
    return res.status(409).json({ error: 'Pacote sem franqueadora associada' });
  }

  const paymentIntent = await paymentIntentService.createPaymentIntent({
    type: 'PROF_HOURS',
    actorUserId: user.userId,
    franqueadoraId,
    unitId: unit_id,
    amountCents: packageData.price_cents,
    metadata: {
      package_id: packageData.id,
      package_title: packageData.title,
      hours_qty: packageData.hours_qty,
      payment_method
    }
  });

  res.status(201).json({
    message: 'Pagamento criado com sucesso',
    payment_intent: {
      id: paymentIntent.id,
      type: paymentIntent.type,
      status: paymentIntent.status,
      checkout_url: paymentIntent.checkout_url,
      created_at: paymentIntent.created_at
    },
    package: {
      title: packageData.title,
      hours_qty: packageData.hours_qty,
      price_cents: packageData.price_cents,
      franqueadora_id: franqueadoraId
    }
  });
}));

// ---------------------------------------------------------------------------
// Saldos agregados
router.get('/student/balance', requireAuth, requireRole(['STUDENT', 'ALUNO']), asyncErrorHandler(async (req, res) => {
  const { franqueadora_id, unit_id } = req.query as { franqueadora_id?: string; unit_id?: string };
  const user = req.user;

  const franqueadoraId = await resolveFranqueadoraId({
    franqueadoraId: franqueadora_id,
    unitId: unit_id,
    allowFallback: true
  });

  if (!franqueadoraId) {
    return res.status(400).json({ error: 'franqueadora_id eh obrigatorio' });
  }

  const balance = await balanceService.getStudentBalance(user.userId, franqueadoraId);
  const availableClasses = balance.total_purchased - balance.total_consumed - balance.locked_qty;

  res.json({
    balance: {
      ...balance,
      franqueadora_id: franqueadoraId,
      available_classes: Math.max(0, availableClasses)
    }
  });
}));

router.get('/professor/balance', requireAuth, requireRole(['TEACHER', 'PROFESSOR']), asyncErrorHandler(async (req, res) => {
  const { franqueadora_id, unit_id } = req.query as { franqueadora_id?: string; unit_id?: string };
  const user = req.user;

  const franqueadoraId = await resolveFranqueadoraId({
    franqueadoraId: franqueadora_id,
    unitId: unit_id,
    allowFallback: true
  });

  if (!franqueadoraId) {
    return res.status(400).json({ error: 'franqueadora_id eh obrigatorio' });
  }

  const balance = await balanceService.getProfessorBalance(user.userId, franqueadoraId);
  const availableHours = balance.available_hours - balance.locked_hours;

  res.json({
    balance: {
      ...balance,
      franqueadora_id: franqueadoraId,
      available_hours: Math.max(0, availableHours)
    }
  });
}));

// ---------------------------------------------------------------------------
// Histórico de transações
router.get('/student/transactions', requireAuth, requireRole(['STUDENT', 'ALUNO']), extractPagination, asyncErrorHandler(async (req, res) => {
  const { franqueadora_id, unit_id } = req.query as { franqueadora_id?: string; unit_id?: string };
  const { limit, offset } = req.pagination;
  const user = req.user;

  const franqueadoraId = await resolveFranqueadoraId({
    franqueadoraId: franqueadora_id,
    unitId: unit_id,
    allowFallback: false
  });

  if (!franqueadoraId) {
    return res.status(400).json({ error: 'franqueadora_id eh obrigatorio' });
  }

  let query = supabase
    .from('student_class_tx')
    .select('*', { count: 'exact' })
    .eq('student_id', user.userId)
    .eq('franqueadora_id', franqueadoraId)
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1);

  if (unit_id) {
    query = query.eq('unit_id', unit_id);
  }

  const { data, error, count } = await query;

  if (error) {
    return res.status(500).json({ error: error.message });
  }

  res.set('X-Total-Count', count?.toString() || '0');
  res.json({ transactions: data, franqueadora_id: franqueadoraId });
}));

router.get('/professor/transactions', requireAuth, requireRole(['TEACHER', 'PROFESSOR']), extractPagination, asyncErrorHandler(async (req, res) => {
  const { franqueadora_id, unit_id } = req.query as { franqueadora_id?: string; unit_id?: string };
  const { limit, offset } = req.pagination;
  const user = req.user;

  const franqueadoraId = await resolveFranqueadoraId({
    franqueadoraId: franqueadora_id,
    unitId: unit_id,
    allowFallback: false
  });

  if (!franqueadoraId) {
    return res.status(400).json({ error: 'franqueadora_id eh obrigatorio' });
  }

  let query = supabase
    .from('hour_tx')
    .select('*', { count: 'exact' })
    .eq('professor_id', user.userId)
    .eq('franqueadora_id', franqueadoraId)
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1);

  if (unit_id) {
    query = query.eq('unit_id', unit_id);
  }

  const { data, error, count } = await query;

  if (error) {
    return res.status(500).json({ error: error.message });
  }

  res.set('X-Total-Count', count?.toString() || '0');
  res.json({ transactions: data, franqueadora_id: franqueadoraId });
}));

export default router;
